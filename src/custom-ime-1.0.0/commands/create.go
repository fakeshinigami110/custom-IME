package commands

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"ime-tool/utils"
)

func HandleCreate(cfg Config, forceOverwrite bool) error {
	fmt.Println("ğŸš€ Creating new IME project...")

	if !forceOverwrite {
		exists, err := ProjectExists(cfg.ProjectName)
		if err != nil {
			return fmt.Errorf("failed to check existing projects: %v", err)
		}

		if exists {
			return fmt.Errorf("project '%s' already exists", cfg.ProjectName)
		}
	} else {
		projectDir := filepath.Join(os.Getenv("HOME"), ".config", "custom-ime", cfg.ProjectName)
		if err := os.RemoveAll(projectDir); err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("failed to remove existing project: %v", err)
		}
		fmt.Printf("âœ… Removed existing project: %s\n", cfg.ProjectName)
	}

	if err := createIME(cfg); err != nil {
		return fmt.Errorf("failed to create IME: %v", err)
	}

	return nil
}

func createIME(cfg Config) error {
	fmt.Printf("ğŸ“ Creating project: %s\n", cfg.ProjectName)

	baseDir := filepath.Join(os.Getenv("HOME"), ".config", "custom-ime")
	projectDir := filepath.Join(baseDir, cfg.ProjectName)

	if err := os.MkdirAll(baseDir, 0755); err != nil {
		return fmt.Errorf("failed to create base directory %s: %v", baseDir, err)
	}
	fmt.Printf("ğŸ“ Projects base directory: %s\n", baseDir)

	dirs := []string{
		projectDir,
		filepath.Join(projectDir, "src"),
		filepath.Join(projectDir, "config"),
		filepath.Join(projectDir, "build"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %v", dir, err)
		}
		fmt.Printf("âœ… Created directory: %s\n", dir)
	}

	templates := []struct {
		templateName string
		outputPath   string
	}{
		{"cmake_main.txt", filepath.Join(projectDir, "CMakeLists.txt")},
		{"cmake_src.txt", filepath.Join(projectDir, "src", "CMakeLists.txt")},
		{"ime.h", filepath.Join(projectDir, "src", cfg.IMEName+".h")},
		{"ime.cpp", filepath.Join(projectDir, "src", cfg.IMEName+".cpp")},
		{"addon.conf", filepath.Join(projectDir, "src", cfg.IMEName+"-addon.conf.in")},
		{"ime.conf", filepath.Join(projectDir, "src", cfg.IMEName+".conf")},
	}

	for _, tmpl := range templates {
		tmplPath := filepath.Join("templates", tmpl.templateName)
		if err := generateFromTemplate(tmplPath, tmpl.outputPath, cfg); err != nil {
			return fmt.Errorf("failed to generate %s: %v", tmpl.templateName, err)
		}
		fmt.Printf("âœ… Generated: %s\n", tmpl.outputPath)
	}

	// Ù…Ø¯ÛŒØ±ÛŒØª ÙØ§ÛŒÙ„ Ú©Ø§Ù†ÙÛŒÚ¯ - Ø¨Ø§ Ù…Ø³ÛŒØ± Ø¬Ø¯ÛŒØ¯
	configDest := filepath.Join(projectDir, "config", cfg.IMEName+".conf")
	if cfg.ConfigFile != "" {
		if err := utils.CopyFile(cfg.ConfigFile, configDest); err != nil {
			return fmt.Errorf("failed to copy config file: %v", err)
		}
		fmt.Printf("âœ… Copied config: %s â†’ %s\n", cfg.ConfigFile, configDest)
	} else {
		if err := createDefaultConfig(cfg, configDest); err != nil {
			return fmt.Errorf("failed to create default config: %v", err)
		}
		fmt.Printf("âœ… Created default config: %s\n", configDest)
	}

	fmt.Printf("\nğŸ‰ IME project '%s' created successfully!\n", cfg.ProjectName)
	fmt.Printf("ğŸ“ Project location: %s\n", projectDir)
	fmt.Printf("ğŸ“ All projects are stored in: %s\n", baseDir)
	fmt.Printf("\nNext steps:\n")
	fmt.Printf("  ime-tool install -p %s\n", cfg.ProjectName)

	return nil
}

func generateFromTemplate(templatePath, outputPath string, cfg Config) error {
	tmpl, err := template.ParseFiles(templatePath)
	if err != nil {
		return fmt.Errorf("failed to parse template %s: %v", templatePath, err)
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %v", outputPath, err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, cfg); err != nil {
		return fmt.Errorf("failed to execute template %s: %v", templatePath, err)
	}

	return nil
}

func createDefaultConfig(cfg Config, destPath string) error {
	defaultConfig := fmt.Sprintf(`# %s Configuration
# Auto-generated by omikami

[Settings]
# true / false
convert_numbers_to_binary=false

# keep / ignore
unknown_chars_behavior=keep
add_spaces=true

# leave it blank for no number separator
number_separator=$

# true / false
case_sensitive=false

[Characters]

[Capitals]

[Digits]

[Keywords]

[Operators]


`, cfg.IMEName)

	return os.WriteFile(destPath, []byte(defaultConfig), 0644)
}